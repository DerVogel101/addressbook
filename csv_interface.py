import os
import re
from dataclasses import asdict, fields
from datetime import date
from pathlib import Path

import pandas as pd
import numpy as np

from address import Address
from address_container_interface import AddressDatabaseInterface

class CsvInterface(AddressDatabaseInterface):
    """
    Handles reads, writes, and queries from/to a CSV file.

    :param path: (optional) the path to the CSV file
    """
    def __init__(self, path):
        """
        Initializes the CSVInterface to a valid state.

        :param path: (optional) the path to the CSV file
        """
        self.__path = None
        self.__df_memory = None
        if path is not None:
            self.set_path(path)
            self.open()

    @staticmethod
    def __require_df_memory(func):
        """
        Class-specific decorator.
        Ensures that the object dataframe memory is not None
        before calling the decorated function.

        :param func: the function to be decorated
        :type func: function
        :return: None, an empty list, or the result of the function
        """
        def wrapper(self, *args, **kwargs):
            """
            :param args: Args passed to the function
            :param kwargs: Kwargs passed to the function
            :return: None, an empty list, or the result of the function
            """
            if self.__df_memory is None:
                match func.__name__:
                    case 'search' | 'get_all' | 'get_today_birthdays':
                        return []
                    case _:
                        return None
            return func(self, *args, **kwargs)
        return wrapper

    def set_path(self, path):
        """
        Sets the path to the CSV file, checking if the path is valid.
        Changing the path to another file after reading from one is supported.

        :param path: the path to the CSV file
        :raises KeyError: if the path is invalid
        :return: None
        """
        if os.path.isabs(path):
            match os.name:
                case 'nt':
                    pattern = r"[a-zA-Z]:\\(?:[a-zA-Z0-9]+\\)*[a-zA-Z0-9]+\.csv$"
                case _:
                    pattern = r"^(?:/[^/ ]*)*/?.csv$"
            if re.search(pattern, path):
                self.__path = path
                return None
        else:
            self.__path = os.path.abspath(path)
            return None
        raise KeyError("Invalid path")

    def open(self) -> None:
        """
        Reads the CSV file at the path set in `set_path()` 
        or during construction into object memory.

        :raises IsADirectoryError: if the path is a directory
        :return: None
        """
        if Path(self.__path).is_file():
            with open(self.__path, 'r') as file:
                try:
                    self.__df_memory = pd.read_csv(file, index_col=["id"])
                    
                    # Overwrite autogenerated column types
                    if "number" in self.__df_memory.columns:
                        self.__df_memory["number"] = self.__df_memory["number"].apply(lambda x: str(int(x)) if pd.notnull(x) else None)
                    if "zip_code" in self.__df_memory.columns:
                        self.__df_memory["zip_code"] = self.__df_memory["zip_code"].apply(lambda x: int(x) if pd.notnull(x) else None)

                except pd.errors.EmptyDataError:
                    print("Note: Empty File")
        elif Path(self.__path).is_dir():
            raise IsADirectoryError("Path is a directory")
        return None

    @__require_df_memory
    def save(self) -> None:
        """
        Saves the object memory into the CSV file at the path set in `set_path()`.
        The file is opened with 'a+' mode.

        :raises OSError: If the file open operation fails
        :return: None
        """
        with open(self.__path, 'a+') as file:
            file.truncate(0)
            self.__df_memory.to_csv(file, index=True, index_label="id", header=True)
        return
    
    def close(self) -> None:
        """
        Saves the current data to the file and then closes the CSV file.
        After this call, the object is in an empty state with only the path set.
        A new path may be set or the file re-opened.

        :raises OSError: If save operation fails
        :return: None
        """
        self.save()
        self.__df_memory = None
        return

    @__require_df_memory
    def get_all(self) -> dict[int, Address]:
        """
        Fetches all addresses from the CSV file.

        :return: a dictionary of {ID: :class:`Address`}
        :rtype: dict[int, Address]
        """
        addresses = {}
        for row in self.__df_memory.iterrows():
            addresses[row[0]] = self.__series_to_address(row[1])
        return addresses

    @__require_df_memory
    def get(self, id: int) -> Address | None:
        """
        Fetches the address with the given ID.

        :param id: ID of the Address
        :return: :class:`Address` or None
        :rtype: Address | None
        """
        if id not in self.__df_memory.index:
            return None
        return self.__series_to_address(self.__df_memory.iloc[id])

    @__require_df_memory
    def search(self, search_string: str) -> dict[int, Address]:
        """
        Searches the CSV for addresses matching the given string.

        :param search_string: The search term to look for in the addresses
        :return: a dictionary of {ID: :class:`Address`} matching the search
        :rtype: dict[int, Address]
        """
        result = self.__df_memory[
            self.__df_memory.apply(
                lambda row: row
                .astype(str)
                .str
                .contains(search_string, case=False, na=False)
                .any(),
                axis=1)]
        return {row[0]: self.__series_to_address(row[1]) for row in result.iterrows()}

    @__require_df_memory
    def delete(self, id: int) -> int | None:
        """
        Deletes the address with the given ID from the CSV file.

        :param id: ID of the Address to delete
        :return: the deleted ID, or None if not found
        :rtype: int | None
        """
        try:
            self.__df_memory.drop(index=id, inplace=True)
            return id
        except KeyError:
            return None

    @__require_df_memory
    def update(self, id: int, **kwargs) -> int | None:
        """
        Updates the address with the given ID using the provided kwargs.
        Known keys are all fields in :class:`Address`.

        :param id: the ID of the address to update
        :param kwargs: key-value pairs of address fields to update
        :raises KeyError: if the address with the given ID does not exist
        :return: the ID of the updated address
        :rtype: int
        """
        try:
            row = self.__df_memory.loc[id]
        except IndexError:
            raise KeyError(f"Address with ID {id} does not exist")

        for key, value in kwargs.items():
            if key not in row.keys():
                print("Skipping key, not supported")
                continue
            self.__df_memory.at[id, key] = value
        return id

    def add_address(self, address: Address) -> int:
        """
        Adds the given address to the CSV file.

        :param address: the :class:`Address` to add
        :return: the ID of the added address
        :rtype: int
        """
        serialized_address = asdict(address)
        new_index = 0
        if self.__df_memory is not None and len(self.__df_memory.index) > 0:
            new_index = self.__df_memory.index[-1] + 1
            self.__df_memory = pd.concat([self.__df_memory, pd.DataFrame(data=serialized_address, index=[new_index])])
        else:
            self.__df_memory = pd.DataFrame(data=serialized_address, index=[new_index])
        return new_index

    @__require_df_memory
    def get_today_birthdays(self) -> dict[int, Address]:
        """
        Fetches all addresses with today's date as their birthday.

        :return: a dictionary of {ID: :class:`Address`} with today as the birthday
        :rtype: dict[int, Address]
        """
        result = self.__df_memory[self.__df_memory.birthdate == date.today().strftime("%Y-%m-%d")]
        address_dict = {}
        for row in result.iterrows():
            address_dict[row[0]] = self.__series_to_address(row[1])
        return address_dict    

    @staticmethod
    def __series_to_address(series: pd.Series) -> Address:
        """
        Converts a pandas.Series to an Address, ensuring all types are correct.

        :param series: the series to convert
        :return: the converted :class:`Address`
        :rtype: Address
        """
        row_dict = series.to_dict()
        for key, value in row_dict.items():
            if value == value and value is not None:  # nan != nan for some reason
                if key == 'birthdate':
                    row_dict[key] = date.fromisoformat(str(value))
                elif key in ('phone', 'email', 'street', 'number', 'city'):
                    row_dict[key] = str(value)
                elif key == 'zip_code':
                    row_dict[key] = int(value)
            else:
                row_dict[key] = None
        return Address(**row_dict)

    def __enter__(self):
        self.open()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
        return None

    def __iter__(self):
        self.__index = 0
        return self
    
    def __next__(self):
        if self.__df_memory is None:
            raise StopIteration
        df_indexes = self.__df_memory.index
        if self.__index < len(df_indexes):
            result = self.get(df_indexes[self.__index])
            self.__index += 1
            return result
        else:
            raise StopIteration
